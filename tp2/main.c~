#include <stdlib.h>
#include <stdio.h>
#include <string.h>

struct point_s{
  struct point_s* next;
  struct point_s* previous;
  int x;
  int y;
};

struct point_s* add_point(struct point_s* p,int before, int x, int y);

void save_point(struct point_s** p_res, struct point_s** p_p);

void consume(struct point_s** p_p){
  struct point_s* p=*p_p;
  if(p->next==NULL){
    free(p);
    p=NULL;
  }else{
    p=p->next;
    free(p->previous);
    p->previous=NULL;
  }
}

void try_save( struct point_s** p_res, struct point_s** p_ref, struct point_s** p_p){
  struct point_s* res= *p_res;
  struct point_s* ref= *p_ref;
  struct point_s* p= *p_p;
  if(res->x < p->x){
    save_point(p_res,p_p);
  }else if(res->x > p->x){
    if(ref->x > p->x){
      /*in this case, the line of p can't cut the line and create an interssant intersect before the next point)*/
      consume(p_p);
    }else{
      if(p->next->x != ref->x){
	/*intersect */
	res= add_point(res,0, ref->x,p->y);
        consume(p_ref);
      }
      consume(p_p);
    }
  }else{
    consume(p_p);
  }
}

void save_point(struct point_s** p_res, struct point_s** p_p){
  struct point_s* res= *p_res;
  struct point_s* p= *p_p;
  if(res==NULL){
    res=p;
  }else{
    res->next=p;
    p->previous=res;
    res=p;
    p=p->next;
    res->next->previous=NULL;
    res->next=NULL;
  }
}

void select_point( struct point_s** p_res, struct point_s** p_p1, struct point_s** p_p2){
  struct point_s* res= *p_res;
  struct point_s* p1= *p_p1;
  struct point_s* p2= *p_p2;
  if(res==NULL){
    printf("first save or not...");
    if(p1->x <p2->x){
      save_point(p_res,p_p1);
    }else if(p1->x >p2->x){
      save_point(p_res,p_p2);
    }else if(p1->y== p2->y){
      save_point(p_res,p_p1);
      consume(p_p2);
    }else if(p1->y < p2->y){
      save_point(p_res,p_p1);
    }else{
      save_point(p_res,p_p2);
    }
  }else if(p1->x == p2->x){
      printf("x==x\n");
    if(res->y==p1->y && res->y== p2->y){
      consume(p_p1);
      save_point(p_res,p_p2);
    }else if(p1->y > res->y){
      if(p1->y > p2->y){
	save_point(p_res,p_p1);
      }else{
	save_point(p_res,p_p2);
      }
    }else{
      if(p1->y < p2->y){
	save_point(p_res,p_p1);
      }else{
	save_point(p_res,p_p2);
      }
    }
  }else if(p1->x < p2->x){
    
      printf("y1<y2\n");
    try_save(p_res,p_p2,p_p1);
  }else{
    
      printf("y1>y1\n");
    try_save(p_res,p_p1,p_p2);
  }
}

struct point_s* add_point(struct point_s* p,int before, int x, int y){
  struct point_s* tmp;
  tmp= (struct point_s*) malloc(sizeof(struct point_s));
  tmp->x=x;
  tmp->y=y;
  if(p!=NULL){
    if(before){
      p->previous=tmp;
      tmp->next=p;
    }else{
      p->next=tmp;
      tmp->previous=p;
    }
  }
  return tmp;
}

/*clean fusion between two line*/
struct point_s* fusion( struct point_s* p1, struct point_s* p2){
  struct point_s* tmp, *res;
  res=NULL;
  printf("fusiiiiiioooooonnnnnnnn\n");
  
  printf("res x %d  y %d \n ",p2->next->x,p2->next->y);

  printf("res x %d  y %d \n ",p2->x,p2->y);
  select_point(&res,&p1,&p2);

  printf("res x %d  y %d \n \n",p2->x,p2->y);
  /*we works on tmp to save the first point in result as res*/
  tmp=res;
  printf("res x %d  y %d \n  boucle\n",res->x,res->y);
  while(p1!=NULL && p2!= NULL){
      printf("dedans\n");
    select_point(&tmp,&p1,&p2);
  }
  
  if(p1==NULL){
      printf("p1 vide\n");
    if(p2->y!=0){
      tmp->next=p2;
      p2->previous=tmp;
    }else if(p2->next !=NULL){
      tmp->next=p2->next;
      p2->next->previous=tmp;
    }
  }else{
      printf("p2 vide\n");
    if(p1->y!=0){
      tmp->next=p1;
      p1->previous=tmp;
    }else if(p1->next !=NULL){
      tmp->next=p1->next;
      p1->next->previous=tmp;
    }
  }
  return res;
}

/*return a clean line*/
struct point_s* resolve(struct point_s*p, int length){
  printf("on resoud %d\n", length);
  if(length==1){
    return p;
  }else if(length==2){
    if(p->x < p->next->x){
      printf("on resoud 2 dans le cas simple\n");
      /*if the entry file is clean( x y z with x<z) we are in this case*/
      return  p;
    }else{      
      printf("on resoud 2 dans le cas dur\n");
      p->previous=p->next;
      p->next->next=p;
      p->next=NULL;
      return p->previous;
    }
  }else{
    /*we cut in 2 sub problems.*/
    struct point_s* tmp1, * tmp2;
    int i,j;
    j=length/2;
    tmp1 = p;
    tmp2 = p->next;
    for(i=0;i<j;i++){
      tmp2=tmp2->next;
    }
    tmp2->previous->next=NULL;
    tmp2->previous=NULL;
    tmp1=resolve(tmp1,j);
      printf("resolu, ça bloque plus haut\n");
    tmp2=resolve(tmp2, length-j);
      printf("resolu, ça bloque plus haut\n");
    /*fusion of 2 sub problems*/
    return fusion(tmp1, tmp2);
  }
}

void pt_to_buff(char* buff, struct point_s *p,int length){
  sprintf(buff,"");
  for(int i=0; i<length;i++){
    sprintf(buff,"%s %d,%d",buff,p->x,p->y);
    p=p->next;
  }
}

void subdiv(char tmp[3][5],char * buff){
  int tmpcpt,cpt,i;
  i=0;
  cpt=0;
  tmpcpt;
  while(buff[i]!=NULL && buff[i]!='\0'){
    printf("%c // %d %d\n",buff[i],cpt,i);
    if(buff[i]==' ' || buff[i]=='/' || buff[i]==','){
      cpt=0;
      tmpcpt++;
    }else{
      tmp[tmpcpt][cpt]=buff[i];
      cpt++;
    }
  }
}

/*Only read and write in file. Launch the fonction resolve on the polyline*/
int main(int argc, char** argv){
  FILE* ifile;
  FILE* ofile;
  int nb_point;
  if(argc!=2){
    int cpt;
    struct point_s* first;
    first=NULL;
    cpt=1;
    printf("Veuillez renseigner un seul fichier. mode entier direct\n");
    while(cpt<argc-3){
      first=add_point(first,1,atoi(argv[cpt++]),atoi(argv[cpt++]));      
      first=add_point(first,1,atoi(argv[cpt++]),0);
    }
  }
  ifile= fopen(argv[1], "r");
  if(ifile!=NULL){
    char buff[10];
    fgets(buff,10,ifile);
    nb_point= atoi(buff)*2;
    printf("%d points\n", nb_point);
  }
  
  if(ifile!=NULL){
    int cpt;
    struct point_s* first;
    char buff[100];
    first=NULL;
    while (fgets(buff, 100, ifile)){
      char tmp[3][5];
      int int1, int2,int3;
      printf("buff\n%s \n",buff);
      subdiv(tmp,buff);
      //tmp[0]= strtok (buff,delim);
      int1 = atoi(tmp[0]);
      //tmp[1] = strtok (NULL,delim);
      int2 = atoi(tmp[1]);
      //tmp[2] = (NULL,delim);
      int3 = atoi(tmp[2]);
      
      if (cpt<nb_point){
	first=add_point(first,1,int3,0);
	cpt++;
      }
      if (cpt<nb_point){
	first=add_point(first,1,int1,int2);
	cpt++;
      }
    }
    
    pt_to_buff(buff,first, nb_point);
    printf("%s\n",buff);
    first = resolve(first, nb_point);
    fclose(ifile);
  
    //ofile= fopen("out.svg", "r");
    
    pt_to_buff(buff,first, nb_point);
    printf("%s\n",buff);
    //fclose(ofile);
  }
}
